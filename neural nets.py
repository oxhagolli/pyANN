from random import random
from math import e


class Neuron:
    def __init__(self, size, alpha):
        """
        Constructor for the Neuron
        :param size: Size of the input vector
        :param alpha: Learning constant
        """
        self.weights = []
        for i in range(size):
            self.weights.append(random())
        self.alpha = alpha

    def __str__(self):
        """
        Print the current state of the Neuron
        :return: A string with the weights array
        """
        return str(self.weights)

    def feed_forward(self, in_vector):
        """
        This function sums the values generated by multiplying each element
        in in_vector by respective weights
        :param in_vector: The input vector to evaluate
        :return: a rounded value to the 10th digit [0,1]
        """
        sigma = sum([x * y for x, y in zip(in_vector, self.weights)])
        return round(self.activate(sigma), 10)

    def activate(self, in_sum):
        """
        Activation function, uses a sigmoid curve.
        :param in_sum: The sum of inputs * weights
        :return: A value between 0 and 1
        """
        if in_sum < -709:
            in_sum = -709  # prevent pow from crashing (py can't support e**>709)
        return 1 / (1 + e ** (-in_sum))

    def train(self, in_vector, desired):
        """
        Readjust the weights if the output is not as desired.
        :param in_vector: the training input vector
        :param desired: the desired value for the given input vector
        """
        output = self.feed_forward(in_vector)
        error = desired - output
        for i in range(len(self.weights)):
            self.weights[i] += self.alpha * error * in_vector[i]


# EXAMPLE USAGE: TRAINING

n = Neuron(2, 0.01)

for i in range(100000):
    v = [random(), random()]
    desired = 0
    if v[0] > v[1]:
        desired = 1
    n.train(v, desired)

# EXAMPLE USAGE: VALIDATION & PREDICTION

print(n.feed_forward([5000, 10000]))  # Should return something close to 0
print(n.feed_forward([-10000, -50000]))  # Should return something close to 1
print(n.feed_forward([-0.5, -0.6]))  # Should return something ~> 0.5
print(n.feed_forward([0, 0]))  # Should return something ~ 0.5
